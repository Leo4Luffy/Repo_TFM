[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial básico con SeqBreed",
    "section": "",
    "text": "Este es el sitio web del “Tutorial básico con SeqBreed”. Aquí encontrará algunos de los resultados obtenidos al realizar mi trabajo de grado del Máster de Mejora Genética Animal y Biotecnología de la Reproducción, específicamente, los resultados obtenidos al usar el módulo de Python SeqBreed.\nA lo largo de este tutorial usaré bloques informativos para resaltar algún aspecto importante. Abajo encontrará un ejemplo de los bloques y su significado.\n\nInformación sobre un tema de interés.\n\n\nInformación sobre una función usada en la codificación."
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Tutorial básico con SeqBreed",
    "section": "Licencia",
    "text": "Licencia\nEsta página web es de uso gratuito y está licenciado bajo la licencia licencia Creative Commons Attribution-NonCommercial-NoDerivs 4.0. Sí tiene alguna inquietud al respecto, por favor informar a los correos jollopezma@unal.edu.co y mperezenciso@gmail.com."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Los datos",
    "section": "",
    "text": "En este tutorial usaré los conjuntos de datos del Rice SNP-Seek Database, el cual contiene información sobre genotipos de SNP y fenotipos de distintas variedades de arroz (Oryza sativa L.)."
  },
  {
    "objectID": "preface.html#hola-2",
    "href": "preface.html#hola-2",
    "title": "Los datos",
    "section": "Hola 2",
    "text": "Hola 2"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Los datos",
    "section": "",
    "text": "Hola 2\nsggs dhd jjd djd"
  },
  {
    "objectID": "data.html#references",
    "href": "data.html#references",
    "title": "Los datos",
    "section": "References",
    "text": "References\n\n\n\n\nPurcell, Shaun, Benjamin Neale, Kathe Todd-Brown, Lori Thomas, Manuel A. R. Ferreira, David Bender, Julian Maller, et al. 2007. “PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses.” The American Journal of Human Genetics 81 (3): 559–75. https://doi.org/10.1086/519795."
  },
  {
    "objectID": "data.html#referencias",
    "href": "data.html#referencias",
    "title": "Los datos",
    "section": "Referencias",
    "text": "Referencias\n\n\n\n\nPurcell, Shaun, Benjamin Neale, Kathe Todd-Brown, Lori Thomas, Manuel A. R. Ferreira, David Bender, Julian Maller, et al. 2007. “PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses.” The American Journal of Human Genetics 81 (3): 559–75. https://doi.org/10.1086/519795."
  },
  {
    "objectID": "data.html#referencia-bibliográfica",
    "href": "data.html#referencia-bibliográfica",
    "title": "Los datos",
    "section": "Referencia bibliográfica",
    "text": "Referencia bibliográfica\n\n\n\n\nPurcell, Shaun, Benjamin Neale, Kathe Todd-Brown, Lori Thomas, Manuel A. R. Ferreira, David Bender, Julian Maller, et al. 2007. “PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses.” The American Journal of Human Genetics 81 (3): 559–75. https://doi.org/10.1086/519795."
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "Modelos de predicción",
    "section": "",
    "text": "Los datos del carácter tiempo de floración los analice utilizando los métodos del mejor predictor lineal insesgado (BLUP) y del mejor predictor lineal insesgado genómico de un solo paso (ssGBLUP), y las precisiones de la predicción las calculé a través del coeficiente de correlación entre los valores fenotípicos observados y predichos.\n\nBLUP\nPara llevar a cabo la predicción usando el BLUP en individuos no genotipados, se aplicó el siguiente modelo:\n\\[\n\\textbf{y} = \\mu + \\textbf{Z} \\textbf{g} + \\textbf{e},\n\\] donde \\(y\\) es el fenotipo a predecir, \\(\\mu\\) es la media de la población, \\(g\\) representa los efectos aleatorios genéticos aditivos, \\(Z\\) es la matriz de incidencia que relaciona a \\(g\\) con \\(y\\), y \\(e\\) es el vector de residuos. Se asume que \\(g\\) ~ \\(N(0, A \\sigma_{g}^{2})\\), donde \\(A\\) representa la matriz de parentesco basada en información del pedigrí, y que \\(\\sigma_{g}^{2}\\) es la varianza genética aditiva. Se asume también que \\(e\\) ~ \\(N(0, I \\sigma_{e}^{2})\\), siendo \\(I\\) la matriz identidad, y \\(\\sigma_{e}^{2}\\) la varianza residual.\nLa figura a continuación (Figure 1) representa el método BLUP.\n\n\n\n\n\nFigure 1: Esquema del método del mejor predictor lineal insesgado (BLUP).\n\n\n\n\n\n\nssGBLUP\nEl método ssGBLUP (Legarra, Aguilar, and Misztal 2009) incluye información de individuos genotipados y no genotipados mediante la combinación de la matriz de parentesco basada en información genómica (matriz G) y la matriz A. Este método utiliza el mismo modelo anterior con la excepción de que \\(g\\) ~ \\(N(0, H \\sigma_{g}^{2})\\), donde \\(H\\) es la matriz de parentesco combinada, cuya estructura se observa a continuación:\n\\[\nH =\n\\begin{bmatrix}\nA_{11} + A_{12} A_{22}^{-1} ( G - A_{22} ) A_{22}^{-1}  A_{21} & A_{12} A_{22}^{-1} G \\\\\nG A_{22}^{-1} A_{12}' & G\n\\end{bmatrix}\n,\n\\]\ndonde \\(A_{11}\\), \\(A_{12}\\), \\(A_{21}\\) y \\(A_{22}\\) son submatrices de A, siendo \\(A_{11}\\) la submatriz de los individuos sin genotipo, \\(A_{22}\\) la submatriz de los individuos con genotipo, y \\(A_{12}\\) y \\(A_{21}\\) las submatrices que contienen las relaciones genéticas aditivas esperadas entre individuos con genotipo y sin genotipo. Para el cálculo de la matriz H, se obtuvo la matriz G utilizando el método de (VanRaden 2008), \\(\\frac{XX'}{2 \\sum_{j=1}^{nSNP} p_{j} (1 - p_{j})}\\), donde \\(X\\) es una matriz de dimensión n x nSNP que contiene los genotipos, \\(p_{j}\\) es la frecuencia del j-ésimo SNP, \\(n\\) corresponde al número de individuos y nSNP representa al número de SNP.\nLa figura a continuación (Figure 2) representa el método ssGBLUP.\n\n\n\n\n\nFigure 2: Esquema del método del mejor predictor lineal insesgado de un solo paso (ssGBLUP).\n\n\n\n\n\nAl comparar los métodos BLUP y ssGBLUP, con el ssGBLUP se obtienen predicciones más precisas y una selección más eficiente de genotipos superiores, en virtud de una mejor estimación del parentesco entre individuos. Esto último debido al uso de información genómica y a la construcción a través de esta información de matrices de relación realizadas.\n\n\n\nReferencia bibliográfica\n\n\n\n\nLegarra, A., I. Aguilar, and I. Misztal. 2009. “A Relationship Matrix Including Full Pedigree and Genomic Information.” Journal of Dairy Science 92 (9): 4656–63. https://doi.org/10.3168/jds.2009-2061.\n\n\nVanRaden, P. M. 2008. “Efficient Methods to Compute Genomic Predictions.” Journal of Dairy Science 91 (11): 4414–23. https://doi.org/10.3168/jds.2007-0980."
  },
  {
    "objectID": "index.html#bienvenido",
    "href": "index.html#bienvenido",
    "title": "Tutorial básico con SeqBreed",
    "section": "Bienvenido",
    "text": "Bienvenido\nEste es el sitio web del “Tutorial básico con SeqBreed”. Aquí encontrará algunos de los resultados obtenidos al realizar mi trabajo de grado del Máster de Mejora Genética Animal y Biotecnología de la Reproducción, específicamente, los resultados obtenidos al usar el módulo de Python SeqBreed.\nA lo largo de este tutorial usaré bloques informativos para resaltar algún aspecto importante. Abajo encontrará un ejemplo de los bloques y su significado.\n\nInformación sobre un tema de interés."
  },
  {
    "objectID": "seqbreed.html",
    "href": "seqbreed.html",
    "title": "Precisión de la predición mediante simulación con SeqBreed",
    "section": "",
    "text": "Cada uno de los pasos llevados a cabo en dicho estudio de simulación los describiré a continuación (Figure 1).\n\n\n\n\n\n\n\n\nFigure 1: Esquema de predicción usando simulación con el paquete SeqBreed.\n\n\n\n\n\n1. Uso de genotipos de la población fundadora\nPara simular los datos de fenotipo y de genotipo se usaron los datos con los 100.231 SNP resultantes del control de calidad y que puede descargar en el capítulo donde se describen los datos. Luego, usando las funciones gg.GFounder() y gg.Genome(), como se puede observar en el código a continuación, se obtuvo un archivo que indicó el número de individuos genotipados o individuos de la población fundadora (451), la ploidía (2) y el número de SNP (100.231).\n\nSNP_pos = 'SNP_pos'\n\nGen_Pob_base = gg.GFounder(vcfFile = vcf_IND, snpFile = SNP_pos)\n\n\nCon el argumento vcfFile de la función gg.GFounder(), se carga los genotipos de la llamada población fundadora en formato variant call. Con esta función se obtiene la posición de cada uno de los SNP, y esta a su vez se almacena en el objeto SNP_pos previamente definido.\n\n\nGen_caracteristicas = gg.Genome(snpFile = SNPs_pos, mapFile = None, ploidy = Gen_Pob_base.ploidy,  XChr = 'X', YChr = 'Y', MTChr = 'MT')\n\n\nCon la función gg.Genome() se genera un objeto de clase Genome con algunas de las características del genoma de la población fundadora, como son el nombre y el número de cromosomas. Con el argumento snpFile se especifica el objeto SNP_pos generado en el paso anterior, además de que si se dispone del nombre de los cromosomas sexuales y mitocondrial, estos se especifican en los argumentos XChr, YChr y MT. Aquí, no se dispuso de un archivo con información acerca de recombinación genética y mapeo de genes, por lo cual en el argumento mapFile se colocó “None”.\n\n\n\n2. Especificación de la arquitectura genética (SNP causales (QTN) y sus efectos)\nSe llevo a cabo inicialmente un estudio de asociación a nivel genómico (GWAS) usando el software GCTA(Yang et al. 2011), para identificar las regiones genómicas asociadas con el carácter tiempo de floración. A continuación podrá descargar el archivo que resultó al hacer el GWAS, donde se específica el efecto de los QTN y su localización.\n\n\n\n\n\n\n Datos GWAS\n\n\n\nPosteriomente, con base en el GWAS (Figure 2), se seleccionaron 50 QTN cuyo efecto era proporcional a la varianza aditiva explicada.\n\n\n\n\n\nFigure 2: Visualización del GWAS para el carácter tiempo de floración en el arroz.\n\n\n\n\nA continuación podrá descargar los 50 QTN seleccionados.\n\n\n\n\n\n\n Datos QTN\n\n\n\nPor último, se usó la función gg.QTNs() sobre estos datos generados, indicando también la heredabilidad del carácter (0.7) de acuerdo a resultados previamente reportados (Vourlaki et al. s.f.).\n\nQTN = 'QTN.txt'\n\nQTNs = gg.QTNs(h2 = [0.7], genome = Gen_caracteristicas, qtnFile = QTN)\n\n\nCon la función gg.QTNs() se determina la arquitectura genética para el carácter simulado. Para ello, se especifica un valor deseado de heredabilidad con el argumento h2, se carga el archivo QTN.txt que indica el efecto y la localización de cada uno de los QTN seleccionados anteriormente con el argumento qtnFile, y con el argumento genome se accede a las características del genoma previamente almacenado.\n\n\n\n3. Generación de pedigríes\nInicialmente, se generaron cuatro pedigríes, cada uno de ellos con esquemas de cruzamiento diferentes partiendo de la población fundadora con 451 individuos.\n\n\n\n\n\n\n  \n  \n    \n       \n      Pedigrí 1\n      Pedigri 2\n      Pedigrí 3\n      Pedigrí 4\n    \n  \n  \n    F0\n451\n451\n451\n451\n    F1\n101\n20\n40\n80\n    F2\n800 (10x80)2\n800 (20x40)\n800 (40x20)\n800 (80x10)\n    F3\n800 (800x1)3\n800 (800x1)\n800 (800x1)\n800 (800x1)\n    Total\n2.061\n2.071\n2.091\n2.131\n  \n  \n  \n    \n      1 10 indica el número de descendientes que tendrían los 451 individuos de la generación F0 mediante cruzamiento.\n    \n    \n      2 10x80 indica el número de descendientes (80) que tendrían cada uno de los 10 individuos de la generación F1 por autofecundación, dando un total de 800 individuos en la generación F2.\n    \n    \n      3 800x1 indica el número de descendientes (1) que tendrían cada uno de los 800 individuos de la generación F2 por autofecundación, dando un total de 800 individuos en la generación F3.\n    \n  \n\n\n\n\nA continuación podrá descargar los cuatro pedigríes generados.\n\n\n\n\n\n\n Pedigrí 1   Pedigrí 2   Pedigrí 3   Pedigrí 4\n\n\n\nPosteriormente, se generó mediante simulación utilizando la función gg.Population(), los fenotipos y genotipos de cada uno de los individuos de los cuatro pedigríes anteriores.\n\nPedigri_1 = 'Pedigri_1.txt'\n\nPob_1 = gg.Population(Gen_caracteristicas, pedFile = Pedigri_1, generation = None, qtns = QTNs, gfounders = Gen_Pob_base)\n\n\nPara simular los fenotipos y genotipos a partir de la función gg.Population(), se especifica en el argumento pedFile el pedigrí con los individuos a los cuales dicha información se simulará. Como puede observar, algunos de los objetos generados en pasos anteriores (las características del genoma y los genotipos de la población fundadora), se especifican también aquí.\n\n\nEl módulo de Python SeqBreed simula los fenotipos (\\(y_{i}\\)) de cada uno de los individuos del pedigrí proporcionado con base en la expresión \\(y_{i} = \\mu + g_{i} + e_{i}\\), donde \\(\\mu\\) es la media, \\(g_{i}\\) es el genotipo del individuo, y \\(e_{i}\\) es el error.\n\n\n\n4. Uso de subconjuntos de datos con diferentes densidades de SNP\nDel conjunto de datos total con 100.231 SNP luego del control de calidad, se seleccionaron de forma aleatoria mediante el uso de Plink (Purcell et al. 2007), tres subconjuntos de datos de SNP de manera que el número de marcadores aproximado fuera igual a 1.000, 10.000 y 100.000 SNP. A continuación podrá descargar los subconjuntos de datos de SNP.\n\n\n\n\n\n\n Chip 1   Chip 2   Chip 3\n\n\n\n\nden_chips = ['/chip_1.txt', '/chip_2.txt', '/chip_3.txt', SNP_pos]\n\nchips = []\nfor file in den_chips:\n    chip = gg.Chip(chipFile = file, genome = Gen_caracteristicas, name = file + '_chip')\n    chips.append(chip)\n\n\nPara generar el objeto chip, ya que este variara en los análisis que se presentaran a continuación de acuerdo a distintas densidades aproximadas de marcadores (1.000, 10.000 y 100.000), inicialmente se crea una lista con los distintos subconjuntos de datos de SNP que puede descargar en la instrucción anterior a este código. Luego, se genera el objeto chip a través de un bucle for.\n\n\n\n5. Implementación de los métodos BLUP y ssGBLUP\nSe usó la función sel.doEbv() para llevar a cabo la predicción, usando los modelos BLUP y ssGBLUP descritos anteriormente en el capítulo sobre Modelos de predicción. A continuación podrá observar todo el código que se utilizó.\n\nind_gen_1 = np.arange(2061, dtype = np.int)\n\nind_fen = np.arange(461, dtype = np.int)\n\nitrait = 0\n\n\n.\n\n\n5.1. Método BLUP\n\nsel.doEbv(Pob_1, criterion = 'blup', yIds = ind_fen, h2 = 0.7, itrait = itrait)\n\nebv_aBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_aBLUP = pd.DataFrame(ebv_aBLUP)\n\ny_aBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_aBLUP = pd.DataFrame(y_aBLUP)\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método BLUP.\n\n\n\n\n\n\n Fenotipos observados   Fenotipos predichos\n\n\n\n\n.\n\n\n\n5.2. Método ssGBLUP con densidad de SNP aproximada de 1.000\n\nmX_1 = gg.do_X([Pob_1.inds[i] for i in ind_gen_1], Gen_caracteristicas, Gen_Pob_base, chips[0], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_1, yIds = ind_fen, mkrIds = ind_gen_1, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 1.000.\n\n\n\n\n\n\n Fenotipos observados   Fenotipos predichos\n\n\n\n\n.\n\n\n\n5.3. Método ssGBLUP con densidad de SNP aproximada de 10.000\n\nmX_2 = gg.do_X([Pob_1.inds[i] for i in ind_gen_1], Gen_caracteristicas, Gen_Pob_base, chips[1], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_2, yIds = ind_fen, mkrIds = ind_gen_1, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 10.000.\n\n\n\n\n\n\n Fenotipos observados   Fenotipos predichos\n\n\n\n\n\n5.4. Método ssGBLUP con densidad de SNP aproximada de 100.000\n\nmX_3 = gg.do_X([Pob_1.inds[i] for i in ind_gen_1], Gen_caracteristicas, Gen_Pob_base, chips[2], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_3, yIds = ind_fen, mkrIds = ind_gen_1, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 100.000.\n\n\n\n\n\n\n Fenotipos observados   Fenotipos predichos\n\n\n\nPor último, se usó la correlación entre los valores fenotípicos observados y predichos como medida de predictibilidad, resultados que podrá observar a continuación.\n\n\n\n\n\n\n\n\n\n\n.\n\n\n\n\nReferencia bibliográfica\n\n\n\n\nPérez-Enciso, Miguel, Lino C. Ramírez-Ayala, and Laura M. Zingaretti. 2020. “SeqBreed: A Python Tool to Evaluate Genomic Prediction in Complex Scenarios.” Genetics Selection Evolution 52 (1). https://doi.org/10.1186/s12711-020-0530-2.\n\n\nPurcell, Shaun, Benjamin Neale, Kathe Todd-Brown, Lori Thomas, Manuel A. R. Ferreira, David Bender, Julian Maller, et al. 2007. “PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses.” The American Journal of Human Genetics 81 (3): 559–75. https://doi.org/10.1086/519795.\n\n\nVan-Rossum, G., and Jr. F. L Drake. 1995. Python Reference Manual. Centrum voor Wiskunde en Informatica Amsterdam.\n\n\nVourlaki, I., R. Castanera, S. Ramos-Onsins, J. Casacuberta, and M. Pérez-Enciso. s.f. “Transposable Element Polymorphisms Improve Prediction of Complex Agronomic Traits in Rice.” Frontiers in Plant Science, s.f.\n\n\nYang, Jian, S. Hong Lee, Michael E. Goddard, and Peter M. Visscher. 2011. “GCTA: A Tool for Genome-Wide Complex Trait Analysis.” The American Journal of Human Genetics 88 (1): 76–82. https://doi.org/10.1016/j.ajhg.2010.11.011."
  }
]